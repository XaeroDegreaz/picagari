{"name":"Picagari","tagline":"A zero-configuration contexts and dependency injection (CDI) library for .Net","body":"Picagari - The Dependency Injection Library for .Net / Mono\r\n=\r\n## Synopsis\r\n\r\nPicagari (Malay for _syringe_) is an Inversion of Control (IoC), Contexts and Dependency Injection (CDI) library for .Net / Mono.\r\nA high level example of what Picagari does would be to allow developers to quickly create classes, without having to create factories for constructing objects, or repeatedly having to manually construct objects, and their dependencies (so on, and so forth). It also helps with the decoupling of interfaces and their implementations.\r\n\r\nThere are no configurations to write -- just start by adding the `[Inject]` attributes to your fields / properties, and then use `Bootstrap.Start` on the object that owns them.\r\n\r\n## Basic Code Example\r\nWith some clever usage of the `[Inject]` attribute on your fields and properties you can:\r\n#### Stop doing this:\r\n```C#\r\npublic class Pilot\r\n{\r\n\t//# Dependency\r\n    public SpaceShip SpaceShip;\r\n\t//# Dependency\r\n    public Uniform Uniform;\r\n\r\n    public Pilot()\r\n    {\r\n\t    SpaceShip = new SpaceShip();\r\n\t    SpaceShip.Engine = new Engine();\r\n\t    SpaceShip.Chassis = new Chassis();\r\n\t    SpaceShip.Weapon = new Weapon();\r\n\r\n\t\tUniform = new Uniform();\r\n\t    Uniform.Shirt = new Shirt();\r\n\t\t//# Etc, etc\r\n\r\n\t    Uniform.ZipUp();\r\n\t    SpaceShip.FlyOut();\r\n    }\r\n}\r\n```\r\n\r\n#### And stop doing this:\r\n```C#\r\npublic class Pilot\r\n{\r\n\t//# Dependency\r\n    public SpaceShip SpaceShip;\r\n\t//# Dependency\r\n    public Uniform Uniform;\r\n\r\n    public Pilot()\r\n    {\r\n\t    SpaceShip = new SpaceShip( new Engine(), new Chassis(), new Weapon() );\r\n\t    Uniform = new Uniform( new Shirt() );\r\n\r\n\t    Uniform.ZipUp();\r\n\t    SpaceShip.FlyOut();\r\n    }\r\n}\r\n```\r\n\r\n#Now, do _this:_\r\n```C#\r\npublic class Pilot\r\n{\r\n\t[Inject]\r\n    public SpaceShip SpaceShip;\r\n\t[Inject]\r\n    public Uniform Uniform;\r\n\r\n    public Pilot()\r\n    {\r\n        //# Construct this class' dependencies (and dependencies' dependencies recursively)\r\n        Bootstrap.Start( this );\r\n\t    Uniform.ZipUp();\r\n\t    SpaceShip.FlyOut();\r\n    }\r\n}\r\n```\r\n\r\nYou can also use `Bootstrap.Start()` with other objects:\r\n```C#\r\npublic class Pilot\r\n{\r\n\t//# Dependency\r\n    public SpaceShip SpaceShip;\r\n\t[Inject]\r\n    public Uniform Uniform;\r\n\r\n    public Pilot()\r\n    {\r\n\t    Bootstrap.Start( this );\r\n\t    SpaceShip = Bootstrap.Start( new SpaceShip() );\r\n\t    Uniform.ZipUp();\r\n\t    SpaceShip.FlyOut();\r\n    }\r\n}\r\n```\r\n## Attributes\r\n\r\n|                       \t|                                                                                                                                                                                                                                                                               \t|\r\n|-----------------------\t|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\t|\r\n| `[Inject]`            \t| Constructs, the member, and any of the member's `[Inject]` marked dependencies recursively.                                                                                                                                                                                   \t|\r\n| `[Produces]`          \t| Used on a method, you tell Picagari that you want to use that method for producing the object before you inject it. This is good for when you want to use some logic to decide which implementation of a certain object type you'd like to return (like in the last example). \t|\r\n| `[Default]`           \t| Classes marked with this attribute will be injected by default should there be more than one.implementation of a class, or interface. This ia required on at least one of those classes.                                                                                      \t|\r\n| `[ApplicationScoped]` \t| Classes marked with this attribute will only ever be constructed once. They essentially become reusable singletons, that can be injected over, and over but keep the same reference.                                                                                          \t|\r\n\r\n## Saweet! How do I get started?\r\nThe usual methods:\r\n* Download the [latest binaries](https://github.com/XaeroDegreaz/picagari/releases), and reference them in your project.\r\n* Checkout the repo, and build from source, or reference the project.\r\n* Read the [Wiki](https://github.com/XaeroDegreaz/picagari/wiki).\r\n* Look at some of the [example classes](https://github.com/XaeroDegreaz/picagari/tree/master/Picagari.Examples).\r\n* Inject away!\r\n\r\n## Motivation for the project.\r\n\r\ntl;dr - Because IoC dependency injection is completely awesome.\r\n\r\nI started working in a pure Java shop that uses Java's CDI framework, and I was fascinated by a number of things:\r\n* How powerful it was.\r\n* How much time was saved.\r\n* How reusable my code became, as I was basically able to compartmentalize & isolate modules of code, and just inject them freely into any object that required them.\r\n\r\nI began looking around to see if there were any such frameworks for .Net, the _true_ language of love. I found a few really good ones, namely:\r\n* [Ninject](http://www.ninject.org/)\r\n* [StructureMap](http://structuremap.github.io/structuremap/)\r\n\r\nHowever, my problem with these frameworks is that they rely on some initial configuration, and even more configuration as your project grows. While these frameworks do what they are supposed to do, I felt that they required far too much configuration, and the learning curve was just too steep for something that could be done in a more simple way.\r\n\r\nPicagari uses absolutely no configurations of any kind. I've followed the the experience that I've had with Java's CDI framework, and stripped away configuration.\r\n\r\n## Tests\r\n\r\nThere are NUnit tests available in the solution. They test a variety of things from feature functionality, to infinite inject recursion issues (such as injecting the same type into itself...).\r\n\r\n## Contribute?\r\n\r\n* If you'd like to contribute to the project, simply fork it, hack it, and send a merge request.\r\n* Post bugs / suggestions in the [issue tracker](https://github.com/XaeroDegreaz/picagari/issues).\r\n\r\n## License\r\n\r\nI'm not a lawyer, so in plain English:\r\n\r\nYou can use this library in any project, be it personal, commercial or open source.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}